# Slack Integration Enhancements

Enable Bark to work more naturally with Slack by: (1) using Slack's mrkdwn formatting, (2) splitting responses on unescaped newlines into separate messages, and (3) responding to messages in threads Bark creates.

## Proposed Changes

### Core Module

#### [MODIFY] [chatbot.py](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/core/chatbot.py)

- Update [create_conversation()](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/core/chatbot.py#63-72) to accept an optional `system_prompt_addendum` parameter
- Append the addendum to the base system prompt when creating conversations
- This allows integrations to inject platform-specific formatting instructions

```diff
-def create_conversation(self, system_prompt: str | None = None) -> Conversation:
+def create_conversation(
+    self, 
+    system_prompt: str | None = None,
+    system_prompt_addendum: str | None = None,
+) -> Conversation:
     """Create a new conversation."""
+    prompt = system_prompt or self.settings.system_prompt
+    if system_prompt_addendum:
+        prompt = f"{prompt}\n\n{system_prompt_addendum}"
     return Conversation(
-        system_prompt=system_prompt or self.settings.system_prompt,
+        system_prompt=prompt,
     )
```

---

### Slack Integration

#### [MODIFY] [handler.py](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/integrations/slack/handler.py)

**1. Add Slack mrkdwn system prompt**

Add constant defining Slack-specific formatting instructions:

```python
SLACK_SYSTEM_ADDENDUM = """
You are communicating through Slack. Use Slack's mrkdwn syntax for formatting:
- Bold: *text* (not **text**)
- Italic: _text_ (not *text*)  
- Strikethrough: ~text~
- Code: `code` or ```code block```
- Links: <URL|text>
- Blockquotes: > text
- Bullet lists: - item or â€¢ item

Keep responses concise. Do not use standard markdown syntax.
"""
```

**2. Modify [_get_or_create_conversation()](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/integrations/slack/handler.py#44-54) to pass the addendum**

```diff
 def _get_or_create_conversation(
     self, channel: str, thread_ts: str | None
 ) -> Conversation:
     key = self._get_conversation_key(channel, thread_ts)
     if key not in self._conversations:
-        self._conversations[key] = self._chatbot.create_conversation()
+        self._conversations[key] = self._chatbot.create_conversation(
+            system_prompt_addendum=SLACK_SYSTEM_ADDENDUM
+        )
     return self._conversations[key]
```

**3. Split responses on unescaped newlines**

Modify [_process_and_respond()](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/integrations/slack/handler.py#155-188) to send multiple messages for lines separated by unescaped newlines:

```python
async def _process_and_respond(
    self,
    text: str,
    conversation: Conversation,
    channel: str,
    thread_ts: str,
) -> None:
    # ... existing code to get response ...
    
    # Split on unescaped double newlines (paragraph breaks)
    # Escaped newlines like \\n are preserved
    import re
    messages = re.split(r'(?<!\\)\n\n+', response)
    
    for msg in messages:
        msg = msg.strip()
        if msg:
            # Unescape any escaped newlines
            msg = msg.replace('\\n', '\n')
            await self._client.chat_postMessage(
                channel=channel,
                text=msg,
                thread_ts=thread_ts,
            )
```

**4. Track threads Bark creates and respond to follow-ups**

- Add a set `_bot_threads` to track [(channel, thread_ts)](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/core/chatbot.py#73-105) tuples for threads where Bark has responded
- Modify [_handle_message()](file:///Users/tsumacpro/ScottyLabs/bark/src/bark/integrations/slack/handler.py#125-154) to also process messages in tracked threads (not just DMs)

```python
# In __init__ / dataclass fields:
_bot_threads: set[tuple[str, str]] = field(default_factory=set)

# In _process_and_respond, after posting:
self._bot_threads.add((channel, thread_ts))

# In _handle_message:
async def _handle_message(self, event: dict[str, Any]) -> None:
    if event.get("bot_id") or event.get("subtype") == "bot_message":
        return
    
    channel = event.get("channel", "")
    thread_ts = event.get("thread_ts")
    
    # Handle DMs
    if event.get("channel_type") == "im":
        # ... existing DM handling ...
        
    # Handle replies in threads where Bark has participated
    elif thread_ts and (channel, thread_ts) in self._bot_threads:
        text = event.get("text", "")
        if not text:
            return
        conversation = self._get_or_create_conversation(channel, thread_ts)
        asyncio.create_task(
            self._process_and_respond(text, conversation, channel, thread_ts)
        )
```

## Verification Plan

### Manual Verification

Since this project has no existing tests, we'll need to verify manually through Slack:

1. **Formatting test**: Mention Bark with "Format this in bold and italic: hello world" 
   - Expect: `*bold*` and `_italic_` syntax, not `**bold**` or `*italic*`

2. **Multi-message test**: Mention Bark with "Give me a paragraph about dogs, then a separate paragraph about cats"
   - Expect: Two separate Slack messages (one for each paragraph)

3. **Thread context test**: 
   - Mention Bark in a channel to start a thread
   - Reply in the thread WITHOUT mentioning Bark
   - Expect: Bark responds to the reply since it's in a thread it participated in

> [!IMPORTANT]
> I'll need you to test these scenarios manually once deployed to Slack since the bot needs to be running with valid credentials.
